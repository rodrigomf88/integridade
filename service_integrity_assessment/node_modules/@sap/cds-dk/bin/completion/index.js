const path = require('node:path');

const cds = require('../../bin/cds');
const { bold } = require('../../lib/util/term');

const SUPPORTED_SHELLS = ['bash', 'gitbash', 'zsh', 'ps']

module.exports = Object.assign(completion, {
    handleCompletion,
    options: ['--shell', '--curr', '--line', '--prev'],
    shortcuts: ['-s'],
    flags: ['--add', '--profile', '--remove'],
    help: `
# SYNOPSIS

    -- beta feature --

    *cds completion* <options>

    Adds or removes shell completion for cds commands. Currently supported shells:
        bash, Git Bash, zsh, and PowerShell.

    Depending on the operating system and the shell type, the following files will be changed:
        Linux, WSL
            bash: ~/.bashrc
            zsh: ~/.zshrc
        macOS
            bash: ~/.bash_profile
            zsh: ~/.zshrc
        Windows
            PowerShell: $PROFILE
            Git Bash: ~/.bash_profile

    This command also acts as an internal completion handler for the shell completion scripts.

# OPTIONS

     *--add*
        Add shell completion for cds commands (see examples).

    *--remove*
        Remove shell completion for cds commands (see examples).

    *--shell* <bash | gitbash | ps | zsh>
        Force the shell completion code to be added to the correct shell profile file.
            bash: macOS, Linux, WSL
            zsh: macOS, Linux, WSL
            gitbash: Git Bash for Windows
            ps: PowerShell

# EXAMPLES

   *cds* completion --add                   # Add shell completion for cds commands
   *cds* completion --remove                # Remove shell completion for cds commands
   *cds* completion --add --shell bash      # Add shell completion for cds commands and enforce using bash shell

# ALIASES

   *cds* add completion                     # Add shell completion for cds commands
   *cds* add completion --shell bash        # Add shell completion for cds commands and enforce using bash shell

`});

function getScriptFile(shell) {
    switch (shell) {
        case 'bash':
        case 'gitbash':
            return 'cds-bash.sh'
        case 'ps':
            return 'cds-ps.ps1'
        case 'zsh':
            return 'cds-zsh.sh'
        case '':
        case undefined:
        case null:
            throw 'Internal error: option --shell is missing';
        default:
            throw `Internal error: unsupported shell: ${shell}`;
    }
}

async function completion(_argv, options) {
    if (options.profile) {
        const scriptFile = getScriptFile(options.shell);
        return console.log(path.join(__dirname, 'scripts', scriptFile));
    }

    if (options.add || options.remove) {
        const completionSetup = require('../../lib/init/template/completion/completionSetup');
        await completionSetup.setup(options.add, options);
        return;
    }

    // workaround to parse complex clis containing -- as part of value,
    // e.g. cds completion --line "cds add --"
    const localArgv = process.argv.slice(3);
    const localOptions = {}
    for (let i = 0; i < localArgv.length; i++) {
        localOptions[localArgv[i].replaceAll('-', '')] = localArgv[++i];
    }

    if (localOptions.curr === undefined || localOptions.prev === undefined || localOptions.line === undefined) {
        throw `Some information is missing. Please run ${bold('cds help completion')} for details on how to call this command.`;
    }

    const shell = localOptions.shell;
    if (!SUPPORTED_SHELLS.includes(shell)) {
        throw `internal Error: no completion handler found for type: ${shell}`;
    }

    const currentWord = localOptions.curr;
    const previousWord = localOptions.prev;
    const line = localOptions.line;
    const segments = getSegments(line);
    const cdsCmd = segments[1] || '';

    let completions = await getCompletions(cdsCmd, previousWord, currentWord, segments);
    if (currentWord && shell === 'ps') {
        completions = completions.filter(v => v?.startsWith(currentWord));
    }

    reply(completions);
}

async function handleCompletion(currentWord, previousWord, argv, _util) {
    const allOptionsFlags = ['--add', '--remove', '--shell']
        .filter(e => !argv.includes(e));

    if (currentWord?.startsWith('-')) {
        return allOptionsFlags;
    }

    if (previousWord === '--shell') {
        return ['bash', 'gitbash', 'ps', 'zsh'];
    }

    return allOptionsFlags;
}

function reply(values) {
    if (!Array.isArray(values) || values.length === 0) {
        return;
    }

    values = values.filter(e => !!(typeof e === 'string' && e.trim()));
    values = [...new Set(values)];
    values.sort((a, b) => {
        if (a.startsWith('-') && !b.startsWith('-')) { return 1; }
        if (!a.startsWith('-') && b.startsWith('-')) { return -1; }
        return a.localeCompare(b);
    });

    console.log(values.join('\n'));
}

function getSegments(line) {
    const cliSplit = /'(.*?)'|"(.*?)"|(\\,|\\ |[^, ])+/gs;
    const result = line.match(cliSplit);
    return result.map(s =>
        s.trim()
            .replace(/(\\ )/g, ' ')
            .replace(/^["']|["']$/g, '')
    );
}

function getCdsCmd(cdsCmd) {
    cdsCmd = cds.Shortcuts?.[cdsCmd] ?? cdsCmd;
    return cds.load(cdsCmd);
}

function getAllOptions(cdsCmdObj, segments) {
    return [
        ...cdsCmdObj.options ?? [],
        ...cdsCmdObj.flags?.filter(o => !segments.includes(o)) ?? []
    ];
}

function getUtil() {
    const completionFs = require('./completionFs');
    return {
        cds,
        completionFs
    }
}

async function getCompletions(cdsCmd, previousWord, currentWord, segments) {
    if (cdsCmd === currentWord) {
        return cds.cmds;
    }

    try {
        const cdsCmdObj = getCdsCmd(cdsCmd);
        if (typeof cdsCmdObj.handleCompletion === 'function') {
            return await cdsCmdObj.handleCompletion(currentWord, previousWord, segments, getUtil());
        }

        if (currentWord?.startsWith('-')) {
            return getAllOptions(cdsCmdObj, segments);
        }

        const completionFs = require('./completionFs');
        const all = await completionFs.readdir(currentWord);
        if (!(cdsCmdObj.options?.includes(previousWord) || cdsCmdObj.shortcuts?.includes(previousWord))) {
            const allOptions = getAllOptions(cdsCmdObj, segments);
            all.push(...allOptions);
        }

        return all;
    } catch (err) {
        return [];
    }
}
